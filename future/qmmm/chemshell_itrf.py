#!/usr/bin/env python
#
# Author: Zhendong Li <zhendongli2008@gmail.com>
#         Qiming Sun <osirpt.sun@gmail.com>
#

import numpy
from pyscf import lib
from pyscf import gto
from pyscf import df

'''
QM part interface
'''

def mm_charge(method, coords, charges):
    '''Modify the QM method using the potential generated by MM charges.

    Args:
        method : a HF/DFT/MCSCF/MP2/CCSD ... object

        coords : 2D array, shape (N,3)
            MM particle coordinates
        charges : 1D array
            MM particle charges

    Returns:
        Same method object as the input method with modified 1e Hamiltonian

    Note:
        1. if MM charge and X2C correction are used together, function mm_charge
        needs to be applied before X2C decoration (scf.sfx2c function), eg
        mf = mm_charge(scf.sfx2c(scf.RHF(mol)), [(0.5,0.6,0.8)], [-0.5]).
        2. Once mm_charge function is applied on the "method" object, it affects
        all following calculations eg MP2, CCSD, MCSCF etc

    Examples:

    >>> mol = gto.M(atom='H 0 0 0; F 0 0 1', basis='ccpvdz', verbose=0)
    >>> mf = mm_charge(dft.RKS(mol), [(0.5,0.6,0.8)], [-0.3])
    >>> mf.kernel()
    -101.940495711284
    '''
    if hasattr(method, 'get_hcore'):
        h1e = method.get_hcore()
    else:  # Not SCF objects
        h1e = method._scf.get_hcore
    coords = numpy.asarray(coords, order='C')
    charges = numpy.asarray(charges)

    if 0: # For debug
        v = 0
        for i,q in enumerate(charges):
            mol.set_rinv_origin_(coords[i])
            v += mol.intor('cint1e_rinv_sph') * q
        h1e += v
    else:
        fakemol = _make_fakemol(coords)
        j3c = df.incore.aux_e2(mol, fakemol, intor='cint3c2e_sph', aosym='s2ij')
        v = lib.unpack_tril(numpy.einsum('xk,k->x', j3c, charges))
        h1e += v

    class QMMM(method.__class__):
        def __init__(self):
            self.__dict__.update(method.__dict__)
        def get_hcore(self, *args):
            return h1e
    return QMMM()

#TODO
def mm_charge_grad(method, coords, charges):
    pass

def _make_fakemol(coords):
    nbas = coords.shape[0]
    fakeatm = numpy.zeros((nbas,gto.ATM_SLOTS), dtype=numpy.int32)
    fakebas = numpy.zeros((nbas,gto.BAS_SLOTS), dtype=numpy.int32)
    fakeenv = []
    ptr = 0
    fakeatm[:,gto.PTR_COORD] = numpy.arange(0, nbas*3, 3)
    fakeenv.append(coords.ravel())
    ptr += nbas*3
    fakebas[:,gto.ATOM_OF] = numpy.arange(nbas)
    fakebas[:,gto.NPRIM_OF] = 1
    fakebas[:,gto.NCTR_OF] = 1
# approximate point charge with gaussian distribution exp(-1e9*r^2)
    fakebas[:,gto.PTR_EXP] = ptr
    fakebas[:,gto.PTR_COEFF] = ptr+1
    expnt = 1e9
    fakeenv.append([expnt, 1/(2*numpy.sqrt(numpy.pi)*gto.mole._gaussian_int(2,expnt))])
    ptr += 2
    fakemol = gto.Mole()
    fakemol._atm = fakeatm
    fakemol._bas = fakebas
    fakemol._env = numpy.hstack(fakeenv)
    fakemol.natm = nbas
    fakemol.nbas = nbas
    fakemol._built = True
    return fakemol

if __name__ == '__main__':
    from pyscf import scf
    mol = gto.Mole()
    mol.atom = ''' O                  0.00000000    0.00000000   -0.11081188
                   H                 -0.00000000   -0.84695236    0.59109389
                   H                 -0.00000000    0.89830571    0.52404783 '''
    mol.basis = 'cc-pvdz'
    mol.build()

    mf = mm_charge(scf.RHF(mol), [(0.5,0.6,0.8)], [-0.5])
    print mf.kernel() # -79.5603900667

