<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cc — Coupled Cluster &mdash; PySCF 1.3 alpha documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.3 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PySCF 1.3 alpha documentation" href="index.html" />
    <link rel="next" title="ci — Configuration interaction" href="ci.html" />
    <link rel="prev" title="tddft — Time dependent density functional theory" href="tddft.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ci.html" title="ci — Configuration interaction"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tddft.html" title="tddft — Time dependent density functional theory"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PySCF 1.3 alpha documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-cc">
<span id="cc-coupled-cluster"></span><span id="cc"></span><h1><a class="reference internal" href="#module-cc" title="cc: Computing Coulpled Cluster energy and properties"><tt class="xref py py-mod docutils literal"><span class="pre">cc</span></tt></a> &#8212; Coupled Cluster<a class="headerlink" href="#module-cc" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-cc" title="cc: Computing Coulpled Cluster energy and properties"><tt class="xref py py-mod docutils literal"><span class="pre">cc</span></tt></a> module implements the coupled cluster (CC) model to compute
energy, analytical nuclear gradients, density matrices, excitation states and
relevant properties.</p>
<p>To compute CC energy, you need first create the mean-field calculation using
the mean-field module <a class="reference internal" href="scf.html#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><tt class="xref py py-mod docutils literal"><span class="pre">scf</span></tt></a>.  The mean-field object defines the Hamiltonian
and the problem size which are used to initialize the CC object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Unrelaxed density matrices are evaluated in MO basis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>
</pre></div>
</div>
<p>CCSD(T) energy can be obtained by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t</span>
<span class="k">print</span><span class="p">(</span><span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Gradients are avaialbe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_grad</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span>
<span class="n">grad_n</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">grad_nuc</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">grad_e</span> <span class="o">+</span> <span class="n">grad_nuc</span>
</pre></div>
</div>
<p>The IP/EA-EOM-CCSD can be calculated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">eip</span><span class="p">,</span><span class="n">cip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">eee</span><span class="p">,</span><span class="n">cee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">UCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">eip</span><span class="p">,</span><span class="n">cip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">eea</span><span class="p">,</span><span class="n">cea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All CC methods have two implementations.  One is simple for readablity (suffixed
by <tt class="docutils literal"><span class="pre">_slow</span></tt> in the filename) and the other is extensively optimized for
computing efficiency.  In the slow version,  <tt class="xref py py-func docutils literal"><span class="pre">numpy.einsum()</span></tt> function is
used as the tensor contraction engine.  The code is structured as close as
possible to the formula documented in the literature.  Pure Python/numpy
data structure and functions are used so that the memory management is avoided.
It is easy to make modification or functionalize new methods based on the slow
implementations.</p>
<p>The computing efficient (outcore version) is the default implementation for CC
module.  In this implementation, the CPU usage, memory footprint, memory
efficiency, and IO overhead are carefully considered.  To keep small memory
footprint, most integral tensors are stored on disk.  IO is one of the main
bottleneck in this implementation.  Two techniques have be used to reduce the IO
overhead.  One is the asynchronized IO to overlap the computation and
reading/writing of the 4-indices tensor.  The other is AO-driven for the
contraction of T2 and <tt class="docutils literal"><span class="pre">(vv|vv)</span></tt> integrals in CCSD and CCSD-lambda functions.
These techniques allows the CC module to efficiently handle medium size systems.
In a test system which has 25 occupied, 1500 virtual orbitals, each CCSD
iteration takes about 2.5 hours.  The program does not automatically switch to
AO-driven CCSD for large systems.  You need manually set the <tt class="xref py py-attr docutils literal"><span class="pre">direct</span></tt> to
enable the AO-driven CCSD calculation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">direct</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Some of the CC methods has the more efficient incore implementation which have
all tensors held in memory.  The incore implementation reduces the IO overhead
and optimizes certain formula to gain the best FLOPS.  It is about 30% faster
than the outcore implementation.  Depending on the memory size, the roof of
incore code is around 250 orbitals.</p>
<p>Point group symmetry is not considered in the CCSD program.  But it is used in
the CCSD(T) code to gain the best performance.</p>
<p>Arbitrary orbital frozen, which is not limited to the frozen core, is supported
by the CCSD, CCSD(T), density matrices, EOM-CCSD modules.  But not considered in
the analytical CCSD gradients.</p>
<div class="section" id="data-structure">
<h2>Data structure<a class="headerlink" href="#data-structure" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">CCSD</span></tt> class is the object to hold the restricted CCSD environment
attributes and results.  The environment attributes are the parameters to
control the runtime behaviour of CCSD module, eg the convergence criteria, DIIS
parameters.</p>
<dl class="class">
<dt id="pyscf.cc.ccsd.CCSD">
<em class="property">class </em><tt class="descclassname">pyscf.cc.ccsd.</tt><tt class="descname">CCSD</tt><big>(</big><em>mf</em>, <em>frozen=[]</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Print level.  Default value equals to <tt class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></tt></dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span></dt>
<dd>Allowed memory in MB.  Default value equals to <tt class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></tt></dd>
<dt>conv_tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>converge threshold.  Default is 1e-7.</dd>
<dt>conv_tol_normt <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>converge threshold for norm(t1,t2).  Default is 1e-5.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.  Default is 50.</dd>
<dt>diis_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>DIIS space size.  Default is 6.</dd>
<dt>diis_start_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The step to start DIIS.  Default is 0.</dd>
<dt>direct <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>AO-direct CCSD. Default is False.</dd>
<dt>frozen <span class="classifier-delimiter">:</span> <span class="classifier">int or list</span></dt>
<dd><p class="first">If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>CCSD converged or not</dd>
<dt>e_corr <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>CCSD correlation correction</dd>
<dt>e_tot <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Total CCSD energy (HF + correlation)</dd>
<dt>t1, t2 <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
<dt>l1, l2 <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
</dl>
</div></blockquote>
</dd></dl>

<p>CCSD 1 and 2-particle density matrices, <tt class="docutils literal"><span class="pre">T3</span></tt> amplitudes of CCSD(T) are not stored.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This section documents some examples about how to effectively use CCSD
solver and incorporate CCSD solver with other PySCF functions to do advanced
simulations.  For a complete list of CC examples, please see
<tt class="docutils literal"><span class="pre">pyscf/examples/cc</span></tt>.</p>
<div class="section" id="a-general-solver-for-given-hamiltonian">
<h3>A general solver for given Hamiltonian<a class="headerlink" href="#a-general-solver-for-given-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>The CC module is not limited to molecule system.  The program is implemented as
a general solver for arbitrary Hamiltonians.  It allows users overwriting the
default molecule Hamiltonian with their own effective Hamiltonians.  In this
example, we&#8217;ll create a Hubbard model, and feed its Hamiltonian to CCSD program.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">scf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">ao2mo</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span>

<span class="c">#</span>
<span class="c"># 1D anti-PBC Hubbard model at half filling</span>
<span class="c">#</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">h1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># In PySCF, the faked Hamiltonians just need to be created once in mf object,</span>
<span class="c"># and can be used with mf object everywhere.  Here, the Hubbard model is</span>
<span class="c"># passed to CCSD object with the mf object.</span>
<span class="c">#</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-ccsd-as-casci-active-space-solver">
<h3>Using CCSD as CASCI active space solver<a class="headerlink" href="#using-ccsd-as-casci-active-space-solver" title="Permalink to this headline">¶</a></h3>
<p>CCSD program can be wrapped as a Full CI solver, which can be combined with the
CASCI solver to approximate the multi-configuration calculation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Using the CCSD method as the active space solver to compute an approximate</span>
<span class="sd">CASCI energy.</span>

<span class="sd">A wrapper is required to adapt the CCSD solver to CASCI fcisolver interface.</span>
<span class="sd">Inside the wrapper function, the CCSD code is the same as the example</span>
<span class="sd">40-ccsd_with_given_hamiltonian.py</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">mcscf</span>

<span class="k">class</span> <span class="nc">AsFCISolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">ci0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">fakemol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nelec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nelec</span><span class="p">)</span>
        <span class="n">fakemol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">nelec</span>
        <span class="n">fake_hf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">fakemol</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">fake_hf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eris</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
        <span class="n">e_corr</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">fake_hf</span><span class="o">.</span><span class="n">e_tot</span> <span class="o">+</span> <span class="n">e_corr</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">+</span><span class="n">ecore</span><span class="p">,</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">make_rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span>
        <span class="n">dm1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dm1</span>

    <span class="k">def</span> <span class="nf">make_rdm12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">nmo</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">),</span> <span class="n">dm2</span>

    <span class="k">def</span> <span class="nf">spin_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;H 0 0 0; F 0 0 1.2&#39;</span><span class="p">,</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">AsFCISolver</span><span class="p">()</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="gamma-point-ccsd-with-periodic-boundary-condition">
<h3>Gamma point CCSD with Periodic boundary condition<a class="headerlink" href="#gamma-point-ccsd-with-periodic-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>Integrals in Gamma point of periodic Hartree-Fock calculation are all real.
You can feed the integrals into any pyscf molecular module using the same
operations as the above example.  However, the interface between PBC code and
molecular code are more compatible.  You can treat the crystal object and the
molecule object in the same manner.  In this example, you can pass the PBC mean
field method to CC module to have the gamma point CCSD correlation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Gamma point post-HF calculation needs only real integrals.</span>
<span class="sd">Methods implemented in finite-size system can be directly used here without</span>
<span class="sd">any modification.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;C     0.      0.      0.    </span>
<span class="s">              C     0.8917  0.8917  0.8917</span>
<span class="s">              C     1.7834  1.7834  0.    </span>
<span class="s">              C     2.6751  2.6751  0.8917</span>
<span class="s">              C     1.7834  0.      1.7834</span>
<span class="s">              C     2.6751  0.8917  2.6751</span>
<span class="s">              C     0.      1.7834  1.7834</span>
<span class="s">              C     0.8917  2.6751  2.6751&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;6-31g&#39;</span><span class="p">,</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="c">#</span>
<span class="c"># Switch on incore_anyway flag to ensure that all 2e-integrals are held in</span>
<span class="c"># memory.  These integrals are needed by the post-HF methods.</span>
<span class="c">#</span>
<span class="c"># Note the &quot;incore&quot; version of molecule code is applied here. This limits the</span>
<span class="c"># system size.</span>
<span class="c">#</span>
<span class="n">cell</span><span class="o">.</span><span class="n">incore_anyway</span> <span class="o">=</span> <span class="bp">True</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">mix_density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="s">&#39;weigend&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># Import CC, TDDFT moduel from the molecular implementations</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mytd</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDHF</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="ccsd-with-truncated-mos-to-avoid-linear-dependency">
<h3>CCSD with truncated MOs to avoid linear dependency<a class="headerlink" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency" title="Permalink to this headline">¶</a></h3>
<p>It is common to have linear dependence when one wants to systematically enlarge
the AO basis set to approach complete basis set limit.  The numerical
instability usually has noticeable effects on the CCSD convergence.  An
effective way to remove this negative effects is to truncate the AO sets and
allow the MO orbitals being less than AO functions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">:func:`scf.addons.remove_linear_dep_` discards the small eigenvalues of overlap</span>
<span class="sd">matrix.  This reduces the number of MOs from 50 to 49.  The problem size of</span>
<span class="sd">the following CCSD method is 49.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">remove_linear_dep_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="response-and-un-relaxed-ccsd-density-matrix">
<h3>Response and un-relaxed CCSD density matrix<a class="headerlink" href="#response-and-un-relaxed-ccsd-density-matrix" title="Permalink to this headline">¶</a></h3>
<p>CCSD has two kinds of one-particle density matrices.  The (second order)
un-relaxed density matrix and the (relaxed) response density matrix.  The
<tt class="xref py py-func docutils literal"><span class="pre">CCSD.make_rdm1()</span></tt> function computes the un-relaxed density matrix which is
associated to the regular CCSD energy formula.  The response density is mainly
used to compute the first order response quantities eg the analytical nuclear
gradients.  It is not recommended to use the response density matrix for
population analysis.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c">#</span>
<span class="c"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">CCSD density matrix</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># CCSD density matrix in MO basis</span>
<span class="c">#</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># Relaxed CCSD density matrix in MO basis</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_grad</span>
<span class="n">dm1</span> <span class="o">+=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">response_dm1</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">l1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">l2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="reusing-integrals-in-ccsd-and-relevant-calculations">
<h3>Reusing integrals in CCSD and relevant calculations<a class="headerlink" href="#reusing-integrals-in-ccsd-and-relevant-calculations" title="Permalink to this headline">¶</a></h3>
<p>By default the CCSD solver and the relevant CCSD lambda solver, CCSD(T), CCSD
gradients program generate MO integrals in their own runtime.  But in most
scenario, the same MO integrals can be generated once and reused in the four
modules.  To remove the overhead of recomputing MO integrals, the three module
support user to feed MO integrals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c">#</span>
<span class="c"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">To avoid recomputing AO to MO integral transformation, integrals for CCSD,</span>
<span class="sd">CCSD(T), CCSD lambda equation etc can be reused.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># CCSD module allows you feed MO integrals</span>
<span class="c">#</span>
<span class="n">eris</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># The same MO integrals can be used in CCSD lambda equation</span>
<span class="c">#</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># CCSD(T) module requires the same integrals used by CCSD module</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t</span>
<span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># CCSD gradients need regular MO integrals to solve the relaxed 1-particle</span>
<span class="c"># density matrix</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>  <span class="c"># The electronic part only</span>
</pre></div>
</div>
</div>
<div class="section" id="interfering-ccsd-diis">
<h3>Interfering CCSD-DIIS<a class="headerlink" href="#interfering-ccsd-diis" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="restart-ccsd">
<h3>Restart CCSD<a class="headerlink" href="#restart-ccsd" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="attributes-and-methods">
<h2>Attributes and methods<a class="headerlink" href="#attributes-and-methods" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pyscf.cc.ccsd">
<span id="ccsd"></span><h3>CCSD<a class="headerlink" href="#module-pyscf.cc.ccsd" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="pyscf.cc.ccsd.CC">
<tt class="descclassname">pyscf.cc.ccsd.</tt><tt class="descname">CC</tt><a class="headerlink" href="#pyscf.cc.ccsd.CC" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><tt class="xref py py-class docutils literal"><span class="pre">CCSD</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">pyscf.cc.ccsd.</tt><tt class="descname">CCSD</tt><big>(</big><em>mf</em>, <em>frozen=[]</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>restricted CCSD</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Print level.  Default value equals to <tt class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></tt></dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span></dt>
<dd>Allowed memory in MB.  Default value equals to <tt class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></tt></dd>
<dt>conv_tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>converge threshold.  Default is 1e-7.</dd>
<dt>conv_tol_normt <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>converge threshold for norm(t1,t2).  Default is 1e-5.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.  Default is 50.</dd>
<dt>diis_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>DIIS space size.  Default is 6.</dd>
<dt>diis_start_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The step to start DIIS.  Default is 0.</dd>
<dt>direct <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>AO-direct CCSD. Default is False.</dd>
<dt>frozen <span class="classifier-delimiter">:</span> <span class="classifier">int or list</span></dt>
<dd><p class="first">If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>CCSD converged or not</dd>
<dt>e_corr <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>CCSD correlation correction</dd>
<dt>e_tot <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Total CCSD energy (HF + correlation)</dd>
<dt>t1, t2 <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
<dt>l1, l2 <span class="classifier-delimiter">:</span> <span class="classifier"></span></dt>
<dd>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm1">
<tt class="descname">make_rdm1</tt><big>(</big><em>t1=None</em>, <em>t2=None</em>, <em>l1=None</em>, <em>l2=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm2">
<tt class="descname">make_rdm2</tt><big>(</big><em>t1=None</em>, <em>t2=None</em>, <em>l1=None</em>, <em>l2=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#CCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in MO space.  The density matrix is
stored as</p>
<p>dm2[p,r,q,s] = &lt;p^+ q^+ s r&gt;</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.energy">
<tt class="descclassname">pyscf.cc.ccsd.</tt><tt class="descname">energy</tt><big>(</big><em>mycc</em>, <em>t1</em>, <em>t2</em>, <em>eris</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/ccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>

<span class="target" id="module-pyscf.cc.addons"></span><dl class="function">
<dt id="pyscf.cc.addons.spatial2spin">
<tt class="descclassname">pyscf.cc.addons.</tt><tt class="descname">spatial2spin</tt><big>(</big><em>tx</em>, <em>orbspin=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/addons.html#spatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
<p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.addons.spatial2spinorb">
<tt class="descclassname">pyscf.cc.addons.</tt><tt class="descname">spatial2spinorb</tt><big>(</big><em>tx</em>, <em>orbspin=None</em><big>)</big><a class="headerlink" href="#pyscf.cc.addons.spatial2spinorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
<p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.addons.spin2spatial">
<tt class="descclassname">pyscf.cc.addons.</tt><tt class="descname">spin2spatial</tt><big>(</big><em>tx</em>, <em>orbspin</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/addons.html#spin2spatial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spin2spatial" title="Permalink to this definition">¶</a></dt>
<dd><p>call orbspin_of_sorted_mo_energy to get orbspin</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.cc.ccsd_t">
<span id="ccsd-t"></span><h3>CCSD(T)<a class="headerlink" href="#module-pyscf.cc.ccsd_t" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="module-pyscf.cc.uccsd">
<span id="uccsd"></span><h3>UCCSD<a class="headerlink" href="#module-pyscf.cc.uccsd" title="Permalink to this headline">¶</a></h3>
<p>UCCSD with spatial integrals</p>
<dl class="function">
<dt id="pyscf.cc.uccsd.get_umoidx">
<tt class="descclassname">pyscf.cc.uccsd.</tt><tt class="descname">get_umoidx</tt><big>(</big><em>cc</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#get_umoidx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.get_umoidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get MO boolean indices for unrestricted reference, accounting for frozen orbs.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.uccsd.kernel">
<tt class="descclassname">pyscf.cc.uccsd.</tt><tt class="descname">kernel</tt><big>(</big><em>cc</em>, <em>eris</em>, <em>t1=None</em>, <em>t2=None</em>, <em>max_cycle=50</em>, <em>tol=1e-08</em>, <em>tolnormt=1e-06</em>, <em>verbose=4</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Exactly the same as pyscf.cc.ccsd.kernel, which calls a
<em>local</em> energy() function.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.uccsd.uspatial2spin">
<tt class="descclassname">pyscf.cc.uccsd.</tt><tt class="descname">uspatial2spin</tt><big>(</big><em>cc</em>, <em>moidx</em>, <em>mo_coeff</em><big>)</big><a class="reference internal" href="_modules/pyscf/cc/uccsd.html#uspatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.uspatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the results of an unrestricted mean-field calculation to spin-orbital form.</p>
<p>Spin-orbital ordering is determined by orbital energy without regard for spin.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>fock <span class="classifier-delimiter">:</span> <span class="classifier">(nso,nso) ndarray</span></dt>
<dd>The Fock matrix in the basis of spin-orbitals</dd>
<dt>so_coeff <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nso) ndarray</span></dt>
<dd>The matrix of spin-orbital coefficients in the AO basis</dd>
<dt>spin <span class="classifier-delimiter">:</span> <span class="classifier">(nso,) ndarary</span></dt>
<dd>The spin (0 or 1) of each spin-orbital</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyscf.cc.ccsd_grad">
<span id="ccsd-gradients"></span><h3>CCSD gradients<a class="headerlink" href="#module-pyscf.cc.ccsd_grad" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">cc</span></tt> &#8212; Coupled Cluster</a><ul>
<li><a class="reference internal" href="#data-structure">Data structure</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#a-general-solver-for-given-hamiltonian">A general solver for given Hamiltonian</a></li>
<li><a class="reference internal" href="#using-ccsd-as-casci-active-space-solver">Using CCSD as CASCI active space solver</a></li>
<li><a class="reference internal" href="#gamma-point-ccsd-with-periodic-boundary-condition">Gamma point CCSD with Periodic boundary condition</a></li>
<li><a class="reference internal" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency">CCSD with truncated MOs to avoid linear dependency</a></li>
<li><a class="reference internal" href="#response-and-un-relaxed-ccsd-density-matrix">Response and un-relaxed CCSD density matrix</a></li>
<li><a class="reference internal" href="#reusing-integrals-in-ccsd-and-relevant-calculations">Reusing integrals in CCSD and relevant calculations</a></li>
<li><a class="reference internal" href="#interfering-ccsd-diis">Interfering CCSD-DIIS</a></li>
<li><a class="reference internal" href="#restart-ccsd">Restart CCSD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#attributes-and-methods">Attributes and methods</a><ul>
<li><a class="reference internal" href="#module-pyscf.cc.ccsd">CCSD</a></li>
<li><a class="reference internal" href="#module-pyscf.cc.ccsd_t">CCSD(T)</a></li>
<li><a class="reference internal" href="#module-pyscf.cc.uccsd">UCCSD</a></li>
<li><a class="reference internal" href="#module-pyscf.cc.ccsd_grad">CCSD gradients</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tddft.html"
                        title="previous chapter">tddft &#8212; Time dependent density functional theory</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ci.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">ci</span></tt> &#8212; Configuration interaction</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/cc.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ci.html" title="ci — Configuration interaction"
             >next</a> |</li>
        <li class="right" >
          <a href="tddft.html" title="tddft — Time dependent density functional theory"
             >previous</a> |</li>
        <li><a href="index.html">PySCF 1.3 alpha documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>