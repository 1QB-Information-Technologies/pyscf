<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lib &mdash; PySCF 1.3 alpha documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.3 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PySCF 1.3 alpha documentation" href="index.html" />
    <link rel="next" title="scf — Mean-field methods" href="scf.html" />
    <link rel="prev" title="gto — Molecular structure and GTO basis" href="gto.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scf.html" title="scf — Mean-field methods"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gto.html" title="gto — Molecular structure and GTO basis"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PySCF 1.3 alpha documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-pyscf.lib">
<span id="lib"></span><h1>lib<a class="headerlink" href="#module-pyscf.lib" title="Permalink to this headline">¶</a></h1>
<p>C code and some fundamental functions</p>
<div class="section" id="module-pyscf.lib.parameters">
<span id="parameters"></span><h2>parameters<a class="headerlink" href="#module-pyscf.lib.parameters" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyscf.lib.logger">
<span id="logger"></span><h2>logger<a class="headerlink" href="#module-pyscf.lib.logger" title="Permalink to this headline">¶</a></h2>
<div class="section" id="logging-system">
<h3>Logging system<a class="headerlink" href="#logging-system" title="Permalink to this headline">¶</a></h3>
<div class="section" id="log-level">
<h4>Log level<a class="headerlink" href="#log-level" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Level</td>
<td>number</td>
</tr>
<tr class="row-even"><td>DEBUG4</td>
<td>9</td>
</tr>
<tr class="row-odd"><td>DEBUG3</td>
<td>8</td>
</tr>
<tr class="row-even"><td>DEBUG2</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>DEBUG1</td>
<td>6</td>
</tr>
<tr class="row-even"><td>DEBUG</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>INFO</td>
<td>4</td>
</tr>
<tr class="row-even"><td>NOTE</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>WARN</td>
<td>2</td>
</tr>
<tr class="row-even"><td>ERROR</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>QUIET</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Big <tt class="docutils literal"><span class="pre">verbose</span></tt> value means more noise in the output file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At log level 1 (ERROR) and 2 (WARN), the messages are also output to stderr.</p>
</div>
<p>Each Logger object has its own output destination and verbose level.  So
multiple Logger objects can be created to manage the message system without
affecting each other.
The methods provided by Logger class has the direct connection to the log level.
E.g.  <tt class="xref py py-func docutils literal"><span class="pre">info()</span></tt> print messages if the verbose level &gt;= 4 (INFO):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;info level&#39;</span><span class="p">)</span>
<span class="go">info level</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;info level&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">note</span><span class="p">(</span><span class="s">&#39;note level&#39;</span><span class="p">)</span>
<span class="go">note level</span>
</pre></div>
</div>
</div>
<div class="section" id="timer">
<h4>timer<a class="headerlink" href="#timer" title="Permalink to this headline">¶</a></h4>
<p>Logger object provides timer method for timing.  Set <tt class="xref py py-attr docutils literal"><span class="pre">TIMER_LEVEL</span></tt> to
control which level to output the timing.  It is 5 (DEBUG) by default.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">timer</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">TIMER_LEVEL</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="o">.</span><span class="n">timer</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
<span class="go">    CPU time for test      0.00 sec</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="module-pyscf.lib.numpy_helper">
<span id="numpy-helper"></span><h2>numpy helper<a class="headerlink" href="#module-pyscf.lib.numpy_helper" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.lib.numpy_helper.asarray">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">asarray</tt><big>(</big><em>a</em>, <em>dtype=None</em>, <em>order=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of N-dim arrays to a (N+1) dim array.  It is equivalent to
numpy.asarray function but more efficient.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.cartesian_prod">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">cartesian_prod</tt><big>(</big><em>arrays</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#cartesian_prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.cartesian_prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cartesian product of input arrays.
<a class="reference external" href="http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays">http://stackoverflow.com/questions/1208118/using-numpy-to-build-an-array-of-all-combinations-of-two-arrays</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>arrays <span class="classifier-delimiter">:</span> <span class="classifier">list of array-like</span></dt>
<dd>1-D arrays to form the cartesian product of.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array to place the cartesian product in.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>2-D array of shape (M, len(arrays)) containing cartesian products
formed of input arrays.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cartesian_prod</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="go">array([[1, 4, 6],</span>
<span class="go">       [1, 4, 7],</span>
<span class="go">       [1, 5, 6],</span>
<span class="go">       [1, 5, 7],</span>
<span class="go">       [2, 4, 6],</span>
<span class="go">       [2, 4, 7],</span>
<span class="go">       [2, 5, 6],</span>
<span class="go">       [2, 5, 7],</span>
<span class="go">       [3, 4, 6],</span>
<span class="go">       [3, 4, 7],</span>
<span class="go">       [3, 5, 6],</span>
<span class="go">       [3, 5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.cond">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">cond</tt><big>(</big><em>x</em>, <em>p=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#cond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the condition number</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.condense">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">condense</tt><big>(</big><em>opname</em>, <em>a</em>, <em>locs</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#condense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.condense" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-python"><div class="highlight"><pre><span class="n">nd</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span><span class="n">nd</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">i0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">j0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span>
<span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.ddot">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">ddot</tt><big>(</big><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>c=None</em>, <em>beta=0</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#ddot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.ddot" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix-matrix multiplication for double precision arrays</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.direct_sum">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">direct_sum</tt><big>(</big><em>subscripts</em>, <em>*operands</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#direct_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.direct_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the summation over many operands with the einsum fashion.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;ij,klm-&gt;ijklm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;ij,klm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;i,j,klm-&gt;mjlik&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 6, 3, 5, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;ij-klm-&gt;ijklm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;ij+klm&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 5, 4, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">direct_sum</span><span class="p">(</span><span class="s">&#39;-i-j+klm-&gt;mjlik&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 6, 3, 5, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.dot">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">dot</tt><big>(</big><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>c=None</em>, <em>beta=0</em><big>)</big><a class="headerlink" href="#pyscf.lib.numpy_helper.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix-matrix multiplication for double complex arrays using Gauss&#8217;s
complex multiplication algorithm</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.einsum">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">einsum</tt><big>(</big><em>idx_str</em>, <em>*tensors</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#einsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.einsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a more efficient einsum via reshaping to a matrix multiply.</p>
<p>Current differences compared to numpy.einsum:
This assumes that each repeated index is actually summed (i.e. no &#8216;i,i-&gt;i&#8217;)
and appears only twice (i.e. no &#8216;ij,ik,il-&gt;jkl&#8217;). The output indices must
be explicitly specified (i.e. &#8216;ij,j-&gt;i&#8217; and not &#8216;ij,j&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.hermi_sum">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">hermi_sum</tt><big>(</big><em>a</em>, <em>axes=None</em>, <em>hermi=1</em>, <em>inplace=False</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#hermi_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.hermi_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>a + a.T for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose_sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[ 0.  3.]</span>
<span class="go"> [ 3.  6.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.hermi_triu">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">hermi_triu</tt><big>(</big><em>mat</em>, <em>hermi=1</em>, <em>inplace=True</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#hermi_triu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.hermi_triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the elements of the lower triangular part to fill the upper triangular part.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><p class="first">filltriu : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">1 (default) return a hermitian matrix</div>
<div class="line">2           return an anti-hermitian matrix</div>
</div>
</div></blockquote>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.  3.  6.]</span>
<span class="go"> [ 3.  4.  7.]</span>
<span class="go"> [ 6.  7.  8.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[ 0. -3. -6.]</span>
<span class="go"> [ 3.  4. -7.]</span>
<span class="go"> [ 6.  7.  8.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.norm">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">norm</tt><big>(</big><em>x</em>, <em>ord=None</em>, <em>axis=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy.linalg.norm for numpy 1.6.*</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.pack_tril">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">pack_tril</tt><big>(</big><em>mat</em>, <em>axis=-1</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#pack_tril"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.pack_tril" title="Permalink to this definition">¶</a></dt>
<dd><p>flatten the lower triangular part of a matrix.
Given mat, it returns mat[...,numpy.tril_indices(mat.shape[0])]</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[0 3 4 6 7 8]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.solve_lineq_by_SVD">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">solve_lineq_by_SVD</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#solve_lineq_by_SVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.solve_lineq_by_SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>a * x = b</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.take_2d">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">take_2d</tt><big>(</big><em>a</em>, <em>idx</em>, <em>idy</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#take_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.take_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>a(idx,idy)</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">take_2d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[ 0.  2.]</span>
<span class="go"> [ 6.  8.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.takebak_2d">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">takebak_2d</tt><big>(</big><em>out</em>, <em>a</em>, <em>idx</em>, <em>idy</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#takebak_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.takebak_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse operation of take_2d.  out(idx,idy) += a</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">takebak_2d</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[ 1.  0.  1.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.transpose">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">transpose</tt><big>(</big><em>a</em>, <em>axes=None</em>, <em>inplace=False</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose array for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">[[ 1.  1.  1.]</span>
<span class="go"> [ 1.  1.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.transpose_sum">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">transpose_sum</tt><big>(</big><em>a</em>, <em>inplace=False</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#transpose_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.transpose_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>a + a.T for better memory efficiency</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose_sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[ 0.  3.]</span>
<span class="go"> [ 3.  6.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.unpack_row">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">unpack_row</tt><big>(</big><em>tril</em>, <em>row_id</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#unpack_row"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.unpack_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract one row of the lower triangular part of a matrix.
It is equivalent to unpack_tril(a)[row_id]</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_row</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[ 0. 1. 3.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[ 0. 1. 3.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.unpack_tril">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">unpack_tril</tt><big>(</big><em>tril</em>, <em>filltriu=1</em>, <em>axis=-1</em>, <em>out=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#unpack_tril"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.unpack_tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse operation of pack_tril.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><p class="first">filltriu : int</p>
<blockquote class="last">
<div><div class="line-block">
<div class="line">0           Do not fill the upper triangular part, random number may appear
in the upper triangular part</div>
<div class="line">1 (default) Transpose the lower triangular part to fill the upper triangular part</div>
<div class="line">2           Similar to filltriu=1, negative of the lower triangular part is assign
to the upper triangular part to make the matrix anti-hermitian</div>
</div>
</div></blockquote>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">))</span>
<span class="go">[[ 0. 1. 3.]</span>
<span class="go"> [ 1. 2. 4.]</span>
<span class="go"> [ 3. 4. 5.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 0. 0. 0.]</span>
<span class="go"> [ 1. 2. 0.]</span>
<span class="go"> [ 3. 4. 5.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack_tril</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">6.</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[ 0. -1. -3.]</span>
<span class="go"> [ 1.  2. -4.]</span>
<span class="go"> [ 3.  4.  5.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.numpy_helper.zdot">
<tt class="descclassname">pyscf.lib.numpy_helper.</tt><tt class="descname">zdot</tt><big>(</big><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>c=None</em>, <em>beta=0</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/numpy_helper.html#zdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.numpy_helper.zdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix-matrix multiplication for double complex arrays using Gauss&#8217;s
complex multiplication algorithm</p>
</dd></dl>

<span class="target" id="module-pyscf.lib.linalg_helper"></span><p>Extension to scipy.linalg module</p>
<dl class="function">
<dt id="pyscf.lib.linalg_helper.cho_solve">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">cho_solve</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#cho_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.cho_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve ax = b, where a is hermitian matrix</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">davidson</tt><big>(</big><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em>, <em>follow_state=False</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#davidson"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  a c = e c.  Ref
[1] E.R. Davidson, J. Comput. Phys. 17 (1), 87-94 (1975).
[2] <a class="reference external" href="http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf">http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; array_like_x</span></dt>
<dd>aop(x) to mimic the matrix vector multiplication <span class="math">\(\sum_{j}a_{ij}*x_j\)</span>.
The argument is a 1D array.  The returned value is a 1D array.</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span></dt>
<dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>follow_state <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd>Eigenvalue.  By default it&#8217;s one float number.  If <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> &gt; 1, it
is a list of floats for the lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvalues.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">1D array or list of 1D arrays</span></dt>
<dd>Eigenvector.  By default it&#8217;s a 1D array.  If <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> &gt; 1, it
is a list of arrays for the lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson1">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">davidson1</tt><big>(</big><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em>, <em>follow_state=False</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#davidson1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson1" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  a c = e c.  Ref
[1] E.R. Davidson, J. Comput. Phys. 17 (1), 87-94 (1975).
[2] <a class="reference external" href="http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf">http://people.inf.ethz.ch/arbenz/ewp/Lnotes/chapter11.pdf</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span></dt>
<dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span></dt>
<dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>follow_state <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Converged or not</dd>
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvalues.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.davidson_nosym">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">davidson_nosym</tt><big>(</big><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>left=False</em>, <em>pick=&lt;function pick_real_eigs at 0x2abc7c5cc0c8&gt;</em>, <em>verbose=2</em>, <em>follow_state=False</em><big>)</big><a class="headerlink" href="#pyscf.lib.linalg_helper.davidson_nosym" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization to solve the non-symmetric eigenvalue problem</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span></dt>
<dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span></dt>
<dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>left <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether to calculate and return left eigenvectors.  Default is False.</dd>
<dt>pick <span class="classifier-delimiter">:</span> <span class="classifier">function(w,v,nroots) =&gt; (e[idx], w[:,idx], idx)</span></dt>
<dd>Function to filter eigenvalues and eigenvectors.</dd>
<dt>follow_state <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Converged or not</dd>
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">list of eigenvalues</span></dt>
<dd>The eigenvalues can be sorted real or complex, depending on the
return value of <tt class="docutils literal"><span class="pre">pick</span></tt> function.</dd>
<dt>vl <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>Left eigenvectors. Only returned if <tt class="docutils literal"><span class="pre">left=True</span></tt>.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>Right eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dgeev">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">dgeev</tt><big>(</big><em>abop</em>, <em>x0</em>, <em>precond</em>, <em>type=1</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dgeev"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dgeev" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  A c = e B c.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>abop <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; (array_like_x, array_like_x)</span></dt>
<dd>abop applies two matrix vector multiplications and returns tuple (Ax, Bx)</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd>Initial guess</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvalues.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dgeev1">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">dgeev1</tt><big>(</big><em>abop</em>, <em>x0</em>, <em>precond</em>, <em>type=1</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>verbose=2</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dgeev1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dgeev1" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization method to solve  A c = e B c.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>abop <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; ([array_like_x], [array_like_x])</span></dt>
<dd>abop applies two matrix vector multiplications and returns tuple (Ax, Bx)</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd>Initial guess</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Converged or not</dd>
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvalues.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>The lowest <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt> eigenvectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.dsolve">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">dsolve</tt><big>(</big><em>aop</em>, <em>b</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=30</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>lindep=1e-16</em>, <em>verbose=0</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#dsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson iteration to solve linear equation.  It works bad.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.eig">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">eig</tt><big>(</big><em>aop</em>, <em>x0</em>, <em>precond</em>, <em>tol=1e-12</em>, <em>max_cycle=50</em>, <em>max_space=12</em>, <em>lindep=1e-14</em>, <em>max_memory=2000</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>callback=None</em>, <em>nroots=1</em>, <em>lessio=False</em>, <em>left=False</em>, <em>pick=&lt;function pick_real_eigs at 0x2abc7c5cc0c8&gt;</em>, <em>verbose=2</em>, <em>follow_state=False</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Davidson diagonalization to solve the non-symmetric eigenvalue problem</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop <span class="classifier-delimiter">:</span> <span class="classifier">function([x]) =&gt; [array_like_x]</span></dt>
<dd>Matrix vector multiplication <span class="math">\(y_{ki} = \sum_{j}a_{ij}*x_{jk}\)</span>.</dd>
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array or a list of 1D array</span></dt>
<dd>Initial guess.  The initial guess vector(s) are just used as the
initial subspace bases.  If the subspace is smaller than &#8220;nroots&#8221;,
eg 10 roots and one initial guess, all eigenvectors are chosen as
the eigenvectors during the iterations.  The first iteration has
one eigenvector, the next iteration has two, the third iterastion
has 4, ..., until the subspace size &gt; nroots.</dd>
<dt>precond <span class="classifier-delimiter">:</span> <span class="classifier">function(dx, e, x0) =&gt; array_like_dx</span></dt>
<dd>Preconditioner to generate new trial vector.
The argument dx is a residual vector <tt class="docutils literal"><span class="pre">a*x0-e*x0</span></tt>; e is the current
eigenvalue; x0 is the current eigenvector.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Convergence tolerance.</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>max_space <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>space size to hold trial vectors.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>max_memory <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Allowed memory in MB.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>nroots <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of eigenvalues to be computed.  When nroots &gt; 1, it affects
the shape of the return value</dd>
<dt>lessio <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>How to compute a*x0 for current eigenvector x0.  There are two
ways to compute a*x0.  One is to assemble the existed a*x.  The
other is to call aop(x0).  The default is the first method which
needs more IO and less computational cost.  When IO is slow, the
second method can be considered.</dd>
<dt>left <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Whether to calculate and return left eigenvectors.  Default is False.</dd>
<dt>pick <span class="classifier-delimiter">:</span> <span class="classifier">function(w,v,nroots) =&gt; (e[idx], w[:,idx], idx)</span></dt>
<dd>Function to filter eigenvalues and eigenvectors.</dd>
<dt>follow_state <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If the solution dramatically changes in two iterations, clean the
subspace and restart the iteration with the old solution.  It can
help to improve numerical stability.  Default is False.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>conv <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Converged or not</dd>
<dt>e <span class="classifier-delimiter">:</span> <span class="classifier">list of eigenvalues</span></dt>
<dd>The eigenvalues can be sorted real or complex, depending on the
return value of <tt class="docutils literal"><span class="pre">pick</span></tt> function.</dd>
<dt>vl <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>Left eigenvectors. Only returned if <tt class="docutils literal"><span class="pre">left=True</span></tt>.</dd>
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd>Right eigenvectors.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">dx</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">dx</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">-</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">vl</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">davidson</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">precond</span><span class="p">,</span> <span class="n">nroots</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.eigh_by_blocks">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">eigh_by_blocks</tt><big>(</big><em>h</em>, <em>s=None</em>, <em>labels=None</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#eigh_by_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.eigh_by_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an ordinary or generalized eigenvalue problem for diagonal blocks.
The diagonal blocks are extracted based on the given basis &#8220;labels&#8221;.  The
rows and columns which have the same labels are put in the same block.
One common scenario one needs the block-wise diagonalization is to
diagonalize the matrix in symmetry adapted basis, in which &#8220;labels&#8221; is the
irreps of each basis.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>h, s <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd>Complex Hermitian or real symmetric matrix.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd>labels : list</dd>
<dt>Returns:</dt>
<dd>w, v.  w is the eigenvalue vector; v is the eigenfunction array;
seig is the eigenvalue vector of the metric s.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">eigh_by_blocks</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="go">(array([ 0.,  0.,  2.,  4.]),</span>
<span class="go"> array([[ 1.,  0.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  1.,  0.],</span>
<span class="go">        [ 0.,  0.,  0.,  1.],</span>
<span class="go">        [ 0.,  1.,  0.,  0.]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([ -8.82020545e-01,  -1.81556477e-16,   1.77653793e+00,   5.10548262e+00]),</span>
<span class="go"> array([[  6.40734630e-01,  -7.07106781e-01,   1.68598330e-01,   -2.47050070e-01],</span>
<span class="go">        [ -3.80616542e-01,   9.40505244e-17,   8.19944479e-01,   -4.27577008e-01],</span>
<span class="go">        [ -1.84524565e-01,   9.40505244e-17,  -5.20423152e-01,   -8.33732828e-01],</span>
<span class="go">        [  6.40734630e-01,   7.07106781e-01,   1.68598330e-01,   -2.47050070e-01]]))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">symm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">symm_orb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vnuc_so</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s">&#39;cint1e_nuc_sph&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbsym</span> <span class="o">=</span> <span class="n">symm</span><span class="o">.</span><span class="n">label_orb_symm</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">symm_orb</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">eigh_by_blocks</span><span class="p">(</span><span class="n">vnuc_so</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">orbsym</span><span class="p">)</span>
<span class="go">(array([-4.50766885, -1.80666351, -1.7808565 , -1.7808565 , -1.74189134,</span>
<span class="go">        -0.98998583, -0.98998583, -0.40322226, -0.30242374, -0.07608981]),</span>
<span class="go"> ...)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.krylov">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">krylov</tt><big>(</big><em>aop</em>, <em>b</em>, <em>x0=None</em>, <em>tol=1e-10</em>, <em>max_cycle=30</em>, <em>dot=&lt;built-in function dot&gt;</em>, <em>lindep=1e-15</em>, <em>callback=None</em>, <em>hermi=False</em>, <em>verbose=2</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#krylov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.krylov" title="Permalink to this definition">¶</a></dt>
<dd><p>Krylov subspace method to solve  (1+a) x = b.  Ref:
J. A. Pople et al, Int. J.  Quantum. Chem.  Symp. 13, 225 (1979).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>aop <span class="classifier-delimiter">:</span> <span class="classifier">function(x) =&gt; array_like_x</span></dt>
<dd>aop(x) to mimic the matrix vector multiplication <span class="math">\(\sum_{j}a_{ij} x_j\)</span>.
The argument is a 1D array.  The returned value is a 1D array.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>x0 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd>Initial guess</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Tolerance to terminate the operation aop(x).</dd>
<dt>max_cycle <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>max number of iterations.</dd>
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  The function is terminated when the
smallest eigenvalue of the metric of the trial vectors is lower
than this threshold.</dd>
<dt>dot <span class="classifier-delimiter">:</span> <span class="classifier">function(x, y) =&gt; scalar</span></dt>
<dd>Inner product</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span></dt>
<dd>callback function takes one dict as the argument which is
generated by the builtin function <tt class="xref py py-func docutils literal"><span class="pre">locals()</span></tt>, so that the
callback function can access all local variables in the current
envrionment.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>x : 1D array like b</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span> <span class="o">*</span> <span class="mf">1e-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aop</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">krylov</span><span class="p">(</span><span class="n">aop</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.linalg_helper.safe_eigh">
<tt class="descclassname">pyscf.lib.linalg_helper.</tt><tt class="descname">safe_eigh</tt><big>(</big><em>h</em>, <em>s</em>, <em>lindep=1e-15</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/linalg_helper.html#safe_eigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.linalg_helper.safe_eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve generalized eigenvalue problem  h v = w s v.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The number of eigenvalues and eigenvectors might be less than the
matrix dimension if linear dependency is found in metric s.</p>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>h, s <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd>Complex Hermitian or real symmetric matrix.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>lindep <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Linear dependency threshold.  By diagonalizing the metric s, we
consider the eigenvectors are linearly dependent subsets if their
eigenvalues are smaller than this threshold.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>w, v, seig.  w is the eigenvalue vector; v is the eigenfunction array;
seig is the eigenvalue vector of the metric s.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyscf.lib.chkfile">
<span id="chkfile"></span><h2>chkfile<a class="headerlink" href="#module-pyscf.lib.chkfile" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyscf.lib.chkfile.dump">
<tt class="descclassname">pyscf.lib.chkfile.</tt><tt class="descname">dump</tt><big>(</big><em>chkfile</em>, <em>key</em>, <em>value</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Save array(s) in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>chkfile <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of chkfile.</dd>
</dl>
<p>key : str</p>
<dl class="last docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">array, vector ... or dict</span></dt>
<dd>If value is a python dict, the key/value of the dict will be saved
recursively as the HDF5 group/dataset</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Ci&#39;</span> <span class="p">:</span> <span class="p">{</span><span class="s">&#39;op&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">),</span> <span class="s">&#39;irrep&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;Ag&#39;</span><span class="p">,</span> <span class="s">&#39;Au&#39;</span><span class="p">)}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;symm.chk&#39;</span><span class="p">,</span> <span class="s">&#39;symm&#39;</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s">&#39;symm.chk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;symm&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;symm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;Ci&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;symm/Ci&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;op&#39;, &#39;irrep&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;symm/Ci/op&#39;</span><span class="p">]</span>
<span class="go">&lt;HDF5 dataset &quot;op&quot;: shape (2,), type &quot;|S1&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.dump_mol">
<tt class="descclassname">pyscf.lib.chkfile.</tt><tt class="descname">dump_mol</tt><big>(</big><em>mol</em>, <em>chkfile</em><big>)</big><a class="headerlink" href="#pyscf.lib.chkfile.dump_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Save Mole object in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <tt class="xref py py-class docutils literal"><span class="pre">Mole</span></tt>.</p>
<dl class="last docutils">
<dt>chkfile <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.load">
<tt class="descclassname">pyscf.lib.chkfile.</tt><tt class="descname">load</tt><big>(</big><em>chkfile</em>, <em>key</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load array(s) from chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>chkfile <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of chkfile. The chkfile needs to be saved in HDF5 format.</dd>
<dt>key <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>HDF5.dataset name or group name.  If key is the HDF5 group name,
the group will be loaded into an Python dict, recursively</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>whatever read from chkfile</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&#39;He 0 0 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s">&#39;He.chk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo_coeff</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;He.chk&#39;</span><span class="p">,</span> <span class="s">&#39;scf/mo_coeff&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scfdat</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;He.chk&#39;</span><span class="p">,</span> <span class="s">&#39;scf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scfdat</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;e_tot&#39;, &#39;mo_occ&#39;, &#39;mo_energy&#39;, &#39;mo_coeff&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.load_mol">
<tt class="descclassname">pyscf.lib.chkfile.</tt><tt class="descname">load_mol</tt><big>(</big><em>chkfile</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#load_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.load_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Mole object from chkfile.
The save_mol/load_mol operation can be used a serialization method for Mole object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>chkfile <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A (initialized/built) Mole object</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">lib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&#39;He 0 0 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">save_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s">&#39;He.chk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load_mol</span><span class="p">(</span><span class="s">&#39;He.chk&#39;</span><span class="p">)</span>
<span class="go">&lt;pyscf.gto.mole.Mole object at 0x7fdcd94d7f50&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.lib.chkfile.save_mol">
<tt class="descclassname">pyscf.lib.chkfile.</tt><tt class="descname">save_mol</tt><big>(</big><em>mol</em>, <em>chkfile</em><big>)</big><a class="reference internal" href="_modules/pyscf/lib/chkfile.html#save_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.lib.chkfile.save_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Save Mole object in chkfile</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <tt class="xref py py-class docutils literal"><span class="pre">Mole</span></tt>.</p>
<dl class="last docutils">
<dt>chkfile <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of chkfile.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>No return value</dd>
</dl>
</dd></dl>

<div class="section" id="fast-load">
<h3>Fast load<a class="headerlink" href="#fast-load" title="Permalink to this headline">¶</a></h3>
<p>The results of SCF and MCSCF methods are saved as a Python dictionary in
the chkfile.  One can fast load the results and update the SCF and MCSCF
objects using the python built in methods <tt class="docutils literal"><span class="pre">.__dict__.update</span></tt>, eg:</p>
<div class="highlight-python"><div class="highlight"><pre>from pyscf import gto, scf, mcscf, lib
mol = gto.M(atom=&#39;N 0 0 0; N 1 1 1&#39;, basis=&#39;ccpvdz&#39;)
mf = mol.apply(scf.RHF).set(chkfile=&#39;n2.chk).run()
mc = mcscf.CASSCF(mf, 6, 6).set(chkfile=&#39;n2.chk&#39;).run()

# load SCF results
mf = scf.RHF(mol)
mf.__dict__.update(lib.chkfile.load(&#39;n2.chk&#39;, &#39;scf&#39;))

# load MCSCF results
mc = mcscf.CASCI(mf, 6, 6)
mc.__dict__.update(lib.chkfile.load(&#39;n2.chk&#39;, &#39;mcscf&#39;))
mc.kernel()
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lib</a><ul>
<li><a class="reference internal" href="#module-pyscf.lib.parameters">parameters</a></li>
<li><a class="reference internal" href="#module-pyscf.lib.logger">logger</a><ul>
<li><a class="reference internal" href="#logging-system">Logging system</a><ul>
<li><a class="reference internal" href="#log-level">Log level</a></li>
<li><a class="reference internal" href="#timer">timer</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pyscf.lib.numpy_helper">numpy helper</a></li>
<li><a class="reference internal" href="#module-pyscf.lib.chkfile">chkfile</a><ul>
<li><a class="reference internal" href="#fast-load">Fast load</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="gto.html"
                        title="previous chapter">gto &#8212; Molecular structure and GTO basis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scf.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">scf</span></tt> &#8212; Mean-field methods</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/lib.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scf.html" title="scf — Mean-field methods"
             >next</a> |</li>
        <li class="right" >
          <a href="gto.html" title="gto — Molecular structure and GTO basis"
             >previous</a> |</li>
        <li><a href="index.html">PySCF 1.3 alpha documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>