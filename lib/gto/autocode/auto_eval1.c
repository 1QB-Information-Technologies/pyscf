/*
 * Copyright (C) 2016-  Qiming Sun <osirpt.sun@gmail.com>
 * Description: code generated by  gen-code.cl
 */
#include "grid_ao_drv.h"
#include "vhf/fblas.h"
/*  #C(0 1) G |GTO> */
static void shell_eval_GTOval_ig_sph(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff,
int l, int np, int nc, int blksize)
{
const int degen = (l+1)*(l+2)/2;
const int mblksize = blksize * degen;
const int gtosize = np * mblksize;
int lx, ly, lz, i, k, n;
double fx0[16*2];
double fy0[16*2];
double fz0[16*2];
double *fx1 = fx0 + 16;
double *fy1 = fy0 + 16;
double *fz1 = fz0 + 16;
double gtobuf[gtosize*3];
double *gto0 = gtobuf;
double *gto1 = gto0 + gtosize;
double *gto2 = gto1 + gtosize;
double *gridx = coord;
double *gridy = coord+blksize;
double *gridz = coord+blksize*2;
double s[3];
double c[3];
c[0] = 1 * (-ri[0]);
c[1] = 1 * (-ri[1]);
c[2] = 1 * (-ri[2]);
for (k = 0; k < np; k++) {
                 for (i = 0; i < blksize; i++) {
                         if (NOTZERO(exps[i])) {
fx0[0] = 1;
fy0[0] = 1;
fz0[0] = 1;
for (lx = 1; lx <= l+1; lx++) {
        fx0[lx] = fx0[lx-1] * gridx[i];
        fy0[lx] = fy0[lx-1] * gridy[i];
        fz0[lx] = fz0[lx-1] * gridz[i];
}
GTO_R0I(1, 0, l+0);
for (lx = l, n = 0; lx >= 0; lx--) {
         for (ly = l - lx; ly >= 0; ly--, n++) {
                 lz = l - lx - ly;
s[0] = exps[i] * fx1[lx] * fy0[ly] * fz0[lz];
s[1] = exps[i] * fx0[lx] * fy1[ly] * fz0[lz];
s[2] = exps[i] * fx0[lx] * fy0[ly] * fz1[lz];
gto0[n*blksize+i] = + (-1*c[1]*s[2]) + c[2]*s[1];
gto1[n*blksize+i] = + (-1*c[2]*s[0]) + c[0]*s[2];
gto2[n*blksize+i] = + (-1*c[0]*s[1]) + c[1]*s[0];
        } }
                         } else {
for (n = 0; n < degen; n++) {
gto0[i] = 0;
gto1[i] = 0;
gto2[i] = 0;
} } }
exps += blksize;
gto0 += mblksize;
gto1 += mblksize;
gto2 += mblksize;
}
const char TRANS_N = 'N';
const double D0 = 0;
const double D1 = 1;
for (k = 0; k < 3; k++) {
        dgemm_(&TRANS_N, &TRANS_N, &mblksize, &nc, &np,
               &D1, gtobuf+gtosize*k, &mblksize, coeff, &np,
               &D0, cgto+nc*mblksize*k, &mblksize);
} }
static int fexp_GTOval_ig_sph(double *eprim, double *coord, double *alpha, double *coeff,
int l, int nprim, int nctr, int blksize, double fac)
{
return GTOprim_exp(eprim, coord, alpha, coeff, l, nprim, nctr, blksize, fac*0.5);
}
void GTOval_ig_sph(int nao, int ngrids,int blksize, int bastart, int bascount,
double *ao, double *coord, char *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 3};
GTOeval_sph_drv(shell_eval_GTOval_ig_sph, fexp_GTOval_ig_sph,
param, nao, ngrids,blksize, bastart, bascount,ao, coord, non0table,
atm, natm, bas, nbas, env);
}
/*  #C(0 1) NABLA G |GTO> */
static void shell_eval_GTOval_ipig_sph(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff,
int l, int np, int nc, int blksize)
{
const int degen = (l+1)*(l+2)/2;
const int mblksize = blksize * degen;
const int gtosize = np * mblksize;
int lx, ly, lz, i, k, n;
double fx0[16*4];
double fy0[16*4];
double fz0[16*4];
double *fx1 = fx0 + 16;
double *fy1 = fy0 + 16;
double *fz1 = fz0 + 16;
double *fx2 = fx1 + 16;
double *fy2 = fy1 + 16;
double *fz2 = fz1 + 16;
double *fx3 = fx2 + 16;
double *fy3 = fy2 + 16;
double *fz3 = fz2 + 16;
double gtobuf[gtosize*9];
double *gto0 = gtobuf;
double *gto1 = gto0 + gtosize;
double *gto2 = gto1 + gtosize;
double *gto3 = gto2 + gtosize;
double *gto4 = gto3 + gtosize;
double *gto5 = gto4 + gtosize;
double *gto6 = gto5 + gtosize;
double *gto7 = gto6 + gtosize;
double *gto8 = gto7 + gtosize;
double *gridx = coord;
double *gridy = coord+blksize;
double *gridz = coord+blksize*2;
double s[9];
double c[3];
c[0] = 1 * (-ri[0]);
c[1] = 1 * (-ri[1]);
c[2] = 1 * (-ri[2]);
for (k = 0; k < np; k++) {
                 for (i = 0; i < blksize; i++) {
                         if (NOTZERO(exps[i])) {
fx0[0] = 1;
fy0[0] = 1;
fz0[0] = 1;
for (lx = 1; lx <= l+2; lx++) {
        fx0[lx] = fx0[lx-1] * gridx[i];
        fy0[lx] = fy0[lx-1] * gridy[i];
        fz0[lx] = fz0[lx-1] * gridz[i];
}
GTO_R0I(1, 0, l+0);
GTO_D_I(2, 0, l+1);
GTO_R0I(3, 2, l+0);
for (lx = l, n = 0; lx >= 0; lx--) {
         for (ly = l - lx; ly >= 0; ly--, n++) {
                 lz = l - lx - ly;
s[0] = exps[i] * fx3[lx] * fy0[ly] * fz0[lz];
s[1] = exps[i] * fx2[lx] * fy1[ly] * fz0[lz];
s[2] = exps[i] * fx2[lx] * fy0[ly] * fz1[lz];
s[3] = exps[i] * fx1[lx] * fy2[ly] * fz0[lz];
s[4] = exps[i] * fx0[lx] * fy3[ly] * fz0[lz];
s[5] = exps[i] * fx0[lx] * fy2[ly] * fz1[lz];
s[6] = exps[i] * fx1[lx] * fy0[ly] * fz2[lz];
s[7] = exps[i] * fx0[lx] * fy1[ly] * fz2[lz];
s[8] = exps[i] * fx0[lx] * fy0[ly] * fz3[lz];
gto0[n*blksize+i] = + (-1*c[1]*s[2]) + c[2]*s[1];
gto1[n*blksize+i] = + (-1*c[2]*s[0]) + c[0]*s[2];
gto2[n*blksize+i] = + (-1*c[0]*s[1]) + c[1]*s[0];
gto3[n*blksize+i] = + (-1*c[1]*s[5]) + c[2]*s[4];
gto4[n*blksize+i] = + (-1*c[2]*s[3]) + c[0]*s[5];
gto5[n*blksize+i] = + (-1*c[0]*s[4]) + c[1]*s[3];
gto6[n*blksize+i] = + (-1*c[1]*s[8]) + c[2]*s[7];
gto7[n*blksize+i] = + (-1*c[2]*s[6]) + c[0]*s[8];
gto8[n*blksize+i] = + (-1*c[0]*s[7]) + c[1]*s[6];
        } }
                         } else {
for (n = 0; n < degen; n++) {
gto0[i] = 0;
gto1[i] = 0;
gto2[i] = 0;
gto3[i] = 0;
gto4[i] = 0;
gto5[i] = 0;
gto6[i] = 0;
gto7[i] = 0;
gto8[i] = 0;
} } }
exps += blksize;
gto0 += mblksize;
gto1 += mblksize;
gto2 += mblksize;
gto3 += mblksize;
gto4 += mblksize;
gto5 += mblksize;
gto6 += mblksize;
gto7 += mblksize;
gto8 += mblksize;
}
const char TRANS_N = 'N';
const double D0 = 0;
const double D1 = 1;
for (k = 0; k < 9; k++) {
        dgemm_(&TRANS_N, &TRANS_N, &mblksize, &nc, &np,
               &D1, gtobuf+gtosize*k, &mblksize, coeff, &np,
               &D0, cgto+nc*mblksize*k, &mblksize);
} }
static int fexp_GTOval_ipig_sph(double *eprim, double *coord, double *alpha, double *coeff,
int l, int nprim, int nctr, int blksize, double fac)
{
return GTOprim_exp(eprim, coord, alpha, coeff, l, nprim, nctr, blksize, fac*0.5);
}
void GTOval_ipig_sph(int nao, int ngrids,int blksize, int bastart, int bascount,
double *ao, double *coord, char *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 9};
GTOeval_sph_drv(shell_eval_GTOval_ipig_sph, fexp_GTOval_ipig_sph,
param, nao, ngrids,blksize, bastart, bascount,ao, coord, non0table,
atm, natm, bas, nbas, env);
}
/*  #C(0 1) G |GTO> */
static void shell_eval_GTOval_ig_cart(double *cgto, double *ri, double *exps,
double *coord, double *alpha, double *coeff,
int l, int np, int nc, int blksize)
{
const int degen = (l+1)*(l+2)/2;
const int mblksize = blksize * degen;
const int gtosize = np * mblksize;
int lx, ly, lz, i, k, n;
double fx0[16*2];
double fy0[16*2];
double fz0[16*2];
double *fx1 = fx0 + 16;
double *fy1 = fy0 + 16;
double *fz1 = fz0 + 16;
double gtobuf[gtosize*3];
double *gto0 = gtobuf;
double *gto1 = gto0 + gtosize;
double *gto2 = gto1 + gtosize;
double *gridx = coord;
double *gridy = coord+blksize;
double *gridz = coord+blksize*2;
double s[3];
double c[3];
c[0] = 1 * (-ri[0]);
c[1] = 1 * (-ri[1]);
c[2] = 1 * (-ri[2]);
for (k = 0; k < np; k++) {
                 for (i = 0; i < blksize; i++) {
                         if (NOTZERO(exps[i])) {
fx0[0] = 1;
fy0[0] = 1;
fz0[0] = 1;
for (lx = 1; lx <= l+1; lx++) {
        fx0[lx] = fx0[lx-1] * gridx[i];
        fy0[lx] = fy0[lx-1] * gridy[i];
        fz0[lx] = fz0[lx-1] * gridz[i];
}
GTO_R0I(1, 0, l+0);
for (lx = l, n = 0; lx >= 0; lx--) {
         for (ly = l - lx; ly >= 0; ly--, n++) {
                 lz = l - lx - ly;
s[0] = exps[i] * fx1[lx] * fy0[ly] * fz0[lz];
s[1] = exps[i] * fx0[lx] * fy1[ly] * fz0[lz];
s[2] = exps[i] * fx0[lx] * fy0[ly] * fz1[lz];
gto0[n*blksize+i] = + (-1*c[1]*s[2]) + c[2]*s[1];
gto1[n*blksize+i] = + (-1*c[2]*s[0]) + c[0]*s[2];
gto2[n*blksize+i] = + (-1*c[0]*s[1]) + c[1]*s[0];
        } }
                         } else {
for (n = 0; n < degen; n++) {
gto0[i] = 0;
gto1[i] = 0;
gto2[i] = 0;
} } }
exps += blksize;
gto0 += mblksize;
gto1 += mblksize;
gto2 += mblksize;
}
const char TRANS_N = 'N';
const double D0 = 0;
const double D1 = 1;
for (k = 0; k < 3; k++) {
        dgemm_(&TRANS_N, &TRANS_N, &mblksize, &nc, &np,
               &D1, gtobuf+gtosize*k, &mblksize, coeff, &np,
               &D0, cgto+nc*mblksize*k, &mblksize);
} }
static int fexp_GTOval_ig_cart(double *eprim, double *coord, double *alpha, double *coeff,
int l, int nprim, int nctr, int blksize, double fac)
{
return GTOprim_exp(eprim, coord, alpha, coeff, l, nprim, nctr, blksize, fac*0.5);
}
void GTOval_ig_cart(int nao, int ngrids,int blksize, int bastart, int bascount,
double *ao, double *coord, char *non0table,
int *atm, int natm, int *bas, int nbas, double *env)
{
int param[] = {1, 3};
GTOeval_cart_drv(shell_eval_GTOval_ig_cart, fexp_GTOval_ig_cart,
param, nao, ngrids,blksize, bastart, bascount,ao, coord, non0table,
atm, natm, bas, nbas, env);
}
